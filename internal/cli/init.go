package cli

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/joa23/linear-cli/internal/linear/core"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

// ProjectConfig represents the .linear.yaml config file
type ProjectConfig struct {
	Team    string `yaml:"team"`
	Project string `yaml:"project,omitempty"`
}

const configFileName = ".linear.yaml"

func newInitCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "init",
		Short: "Initialize Linear for this project",
		Long: `Initialize Linear for this project directory.

This command will:
1. Let you select a default team for this project
2. Create a .linear.yaml config file
3. Add usage instructions to AGENTS.md and CLAUDE.md`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runInit()
		},
	}
}

func runInit() error {
	fmt.Println("Linear Project Initialization")
	fmt.Println("==============================")
	fmt.Println()

	client, err := initializeClient()
	if err != nil {
		fmt.Println("❌ Not authenticated. Run 'linear auth login' or set LINEAR_API_KEY.")
		return nil
	}

	// Get teams
	teams, err := client.GetTeams()
	if err != nil {
		return fmt.Errorf("failed to get teams: %w", err)
	}

	if len(teams) == 0 {
		fmt.Println("No teams found in your workspace.")
		return nil
	}

	// Show teams and let user pick
	fmt.Println("Available teams:")
	fmt.Println()
	for i, team := range teams {
		fmt.Printf("  %d. %s (%s)\n", i+1, team.Name, team.Key)
	}
	fmt.Println()

	// Get selection
	var selectedTeam core.Team
	if len(teams) == 1 {
		selectedTeam = teams[0]
		fmt.Printf("Using team: %s (%s)\n", selectedTeam.Name, selectedTeam.Key)
	} else {
		fmt.Print("Select team [1]: ")
		reader := bufio.NewReader(os.Stdin)
		input, _ := reader.ReadString('\n')
		input = strings.TrimSpace(input)

		selection := 1
		if input != "" {
			selection, err = strconv.Atoi(input)
			if err != nil || selection < 1 || selection > len(teams) {
				return fmt.Errorf("invalid selection")
			}
		}
		selectedTeam = teams[selection-1]
	}

	fmt.Println()

	// Write config file
	config := ProjectConfig{Team: selectedTeam.Key}
	if err := writeConfig(config); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}
	fmt.Printf("✅ Created %s (team: %s)\n", configFileName, selectedTeam.Key)

	// Write to AGENTS.md
	if err := appendToAgentFile("AGENTS.md", selectedTeam.Key); err != nil {
		fmt.Printf("⚠️  Could not update AGENTS.md: %v\n", err)
	} else {
		fmt.Println("✅ Updated AGENTS.md")
	}

	// Write to CLAUDE.md
	if err := appendToAgentFile("CLAUDE.md", selectedTeam.Key); err != nil {
		fmt.Printf("⚠️  Could not update CLAUDE.md: %v\n", err)
	} else {
		fmt.Println("✅ Updated CLAUDE.md")
	}

	fmt.Println()
	fmt.Println("Done! You can now use Linear commands without specifying --team.")
	fmt.Println()
	fmt.Println("Try:")
	fmt.Printf("  linear issues list\n")
	fmt.Printf("  linear cycles list\n")
	fmt.Printf("  linear projects list\n")

	return nil
}

func writeConfig(config ProjectConfig) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return err
	}

	header := "# Linear project configuration\n# Generated by 'linear init'\n\n"
	return os.WriteFile(configFileName, []byte(header+string(data)), 0644)
}

func appendToAgentFile(filename, teamKey string) error {
	content := generateAgentContent(teamKey)

	// Check if file exists
	existing, err := os.ReadFile(filename)
	if err != nil && !os.IsNotExist(err) {
		return err
	}

	// Check if the Linear section with this exact content already exists
	// Use a unique marker from the generated content to detect duplicates
	uniqueMarker := "This project uses **Linear** for issue tracking."
	if strings.Contains(string(existing), uniqueMarker) {
		// Already has Linear section with content, skip
		return nil
	}

	// Append to file
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer func() { _ = f.Close() }()

	// Add newlines if file has content
	if len(existing) > 0 && !strings.HasSuffix(string(existing), "\n\n") {
		if strings.HasSuffix(string(existing), "\n") {
			_, _ = f.WriteString("\n")
		} else {
			_, _ = f.WriteString("\n\n")
		}
	}

	_, err = f.WriteString(content)
	return err
}

func generateAgentContent(teamKey string) string {
	return fmt.Sprintf(`## Linear

This project uses **Linear** for issue tracking.
Default team: **%s**

### Creating Issues

`+"```bash"+`
# Create a simple issue
linear issues create "Fix login bug" --team %s --priority high

# Create with full details and dependencies
linear issues create "Add OAuth integration" \
  --team %s \
  --description "Integrate Google and GitHub OAuth providers" \
  --parent %s-100 \
  --depends-on %s-99 \
  --labels "backend,security" \
  --estimate 5

# List and view issues
linear issues list
linear issues get %s-123
`+"```"+`

### Claude Code Skills

Available workflow skills (install with `+"`linear skills install --all`"+`):
- `+"`/prd`"+` - Create agent-friendly tickets with PRDs and sub-issues
- `+"`/triage`"+` - Analyze and prioritize backlog
- `+"`/cycle-plan`"+` - Plan cycles using velocity analytics
- `+"`/retro`"+` - Generate sprint retrospectives
- `+"`/deps`"+` - Analyze dependency chains

Run `+"`linear skills list`"+` for details.
`, teamKey, teamKey, teamKey, teamKey, teamKey, teamKey)
}

// LoadProjectConfig loads the .linear.yaml config from current or parent directories
func LoadProjectConfig() (*ProjectConfig, error) {
	dir, err := os.Getwd()
	if err != nil {
		return nil, err
	}

	// Walk up directory tree looking for config
	for {
		configPath := filepath.Join(dir, configFileName)
		if _, err := os.Stat(configPath); err == nil {
			data, err := os.ReadFile(configPath)
			if err != nil {
				return nil, err
			}

			var config ProjectConfig
			if err := yaml.Unmarshal(data, &config); err != nil {
				return nil, err
			}
			return &config, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}

	return nil, nil // No config found
}

// GetDefaultTeam returns the default team from config, or empty string
func GetDefaultTeam() string {
	config, err := LoadProjectConfig()
	if err != nil || config == nil {
		return ""
	}
	return config.Team
}

// GetDefaultProject returns the default project from config, or empty string
func GetDefaultProject() string {
	config, err := LoadProjectConfig()
	if err != nil || config == nil {
		return ""
	}
	return config.Project
}
